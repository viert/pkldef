@ModuleInfo { minPklVersion = "0.25.0" }
open module pkldef.argoproj.v1alpha1.Application

extends "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/K8sResource.pkl"
import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.0.1#/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"

fixed apiVersion = "argoproj.io/v1alpha1"
fixed kind = "Application"

metadata: ObjectMeta?

spec: ApplicationSpec


class ApplicationSpec {
  /// The project the application belongs to
  project: String = "default"

  /// Source of the application manifests
  source: ApplicationSource

  /// Sources field specifies the list of sources for the application
  sources: Listing<ApplicationSource>

  /// Destination cluster and namespace to deploy the application
  destination: ApplicationDestination

  /// Extra information to show in the Argo CD Application details tab
  info: Listing<KeyValuePair>

  /// ArgoCD sync policy
  syncPolicy: SyncPolicySpec?

  /// Will ignore differences between live and desired states during the diff. Note that these configurations are not
  /// used during the sync process unless the `RespectIgnoreDifferences=true` sync option is enabled.
  ignoreDifferences: IgnoreDifferencesSpec?

  /// RevisionHistoryLimit limits the number of items kept in the application's revision history, which is used for
  /// informational purposes as well as for rollbacks to previous versions. This should only be changed in exceptional
  /// circumstances. Setting to zero will store no history. This will reduce storage used. Increasing will increase the
  /// space used to store the history, so we do not recommend increasing it.
  revisionHistoryLimit: Int?
}

class ApplicationDestination {
  /// cluster API URL
  server: Uri?

  /// cluster name
  name: String?

  /// The namespace will only be set for namespace-scoped resources that have not set a value for .metadata.namespace
  namespace: String?
}

class ApplicationSource {
  /// Can point to either a Helm chart repo or a git repo.
  repoURL: Uri

  /// For Helm, this refers to the chart version, otherwise it is a git ref
  targetRevision: String = "HEAD"

  /// Path relative to git repo root.
  /// This has no meaning for Helm charts pulled directly from a Helm repo instead of git
  path: String?

  /// Set this when pulling directly from a Helm repo. DO NOT set for git-hosted Helm charts
  chart: String?

  /// Helm-specific configuration
  helm: HelmConfig?

  /// Kustomize-specific configuration
  kustomize: KustomizeConfig?

  /// Directory configuration
  directory: DirectoryConfig?

  /// Plugin configuration
  plugin: PluginSpec?
}


class HelmConfig {
  /// If true then adds --pass-credentials to Helm commands to pass credentials to all domains
  passCredentials: Boolean = false

  /// Extra parameters to set (same as setting through values.yaml, but these take precedence)
  parameters: Listing<GenericParam>?

  /// Use the contents of files as parameters (uses Helm's --set-file)
  fileParameters: Listing<FileParam>?

  /// Release name override (defaults to application name)
  releaseName: String?

  /// Helm values files for overriding values in the helm chart
  /// The path is relative to the spec.source.path directory defined above
  valueFiles: Listing<String>?

  /// Ignore locally missing valueFiles when installing Helm chart. Defaults to false
  ignoreMissingValueFiles: Boolean?

  /// Values represented as YAML string. Prefer to use valuesObject if possible
  values: String?

  /// Values represented as an object. This takes precedence over values
  valuesObject: Dynamic?

  /// Skip custom resource definition installation if chart contains custom resource definitions. Defaults to false
  skipCrds: Boolean?

  /// Optional Helm version to template with. If omitted it will fall back to look at the 'apiVersion' in Chart.yaml
  /// and decide which Helm binary to use automatically. This field can be either 'v2' or 'v3'.
  version: ("v2" | "v3")?
}

class GenericParam {
  name: String
  value: String
  /// ensures that value is treated as a string
  forceString: Boolean?
}

class FileParam {
  name: String
  path: String
}

class KustomizeConfig {
  /// Optional kustomize version. Note: version must be configured in argocd-cm ConfigMap
  version: String?

  /// [namePrefix](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/nameprefix/) kustomize transformer
  namePrefix: String?

  /// [nameSuffix](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/namesuffix/) kustomize transformer
  nameSuffix: String?

  /// [commonLabels](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/commonlabels/) kustomize transformer
  commonLabels: Mapping<String, String>?

  /// [commonAnnotations](https://kubectl.docs.kubernetes.io/references/kustomize/kustomization/commonannotations/) kustomize transformer
  commonAnnotations: Mapping<String, String>?

  /// Toggle which enables/disables env variables substitution in commonAnnotations
  commonAnnotationsEnvsubst: Boolean?

  /// Images override
  images: Listing<String>?

  /// Namespace override
  namespace: String?

  /// Replicas override
  replicas: Listing<ReplicasConfig>?

}

class ReplicasConfig {
  name: String
  count: Int
}

typealias GlobPatterns = Listing<String>

class DirectoryConfig {
  recurse: Boolean?
  jsonnet: JsonnetConfig?

  /// Exclude contains glob patterns to match paths against that should be explicitly excluded from being used during
  /// manifest generation. This takes precedence over the `include` field.
  exclude: Listing<String>?

  /// Include contains a glob pattern to match paths against that should be explicitly included during manifest
  /// generation. If this field is set, only matching manifests will be included.
  include: Listing<String>?

}

class JsonnetConfig {
  /// A list of Jsonnet External Variables
  extvars: Listing<ExtVar>
}

class ExtVar {
  name: String
  value: String
  /// You can use "code to determine if the value is either string (false, the default) or Jsonnet code (if code is true).
  code: Boolean?
}

class PluginSpec {
  /// If the plugin is defined as a sidecar and name is not passed, the plugin will be automatically matched with the
  /// Application according to the plugin's discovery rules.
  name: String?

  /// environment variables passed to the plugin
  env: Listing<EnvVar>?

  /// Plugin parameters are new in v2.5.
  parameters: Listing<PluginParam>?
}

open class KeyValuePair {
  name: String
  value: String
}

class EnvVar extends KeyValuePair {}

class PluginParam {
  name: String
  // TODO only one prop of the following can be set at a time
  string: String
  array: Listing<String>
  map: Mapping<String, String>
}

class SyncPolicySpec {
  /// automated sync by default retries failed attempts 5 times with following delays between attempts ( 5s, 10s, 20s, 40s, 80s );
  /// retry controlled using `retry` field
  automated: SyncPolicyAutomationSpec?

  /// Sync options which modifies sync behavior
  syncOptions: SyncOptions?

  /// Sets the metadata for the application namespace. Only valid if CreateNamespace=true (see above), otherwise it's a no-op.
  managedNamespaceMetadata: ObjectMeta?

  /// The retry feature is available since v1.7
  retry: SyncRetrySpec?
}

class SyncRetrySpec {
  /// number of failed sync attempt retries; unlimited number of attempts if less than 0
  limit: Int?

  /// retry backoff options
  backoff: SyncRetryBackoff
}

class SyncRetryBackoff {
  local allowedUnits = List("s", "min", "h", "d")

  /// The amount to back off
  duration: Duration(allowedUnits.contains(this.unit))?

  /// A factor to multiply the base duration after each failed retry
  factor: Int(this > 0)?

  /// the maximum amount of time allowed for the backoff strategy
  maxDuration: Duration(allowedUnits.contains(this.unit))?
}


class SyncPolicyAutomationSpec {
  /// Specifies if resources should be pruned during auto-syncing ( false by default )
  prune: Boolean?

  /// Specifies if partial app sync should be executed when resources are changed
  /// only in target Kubernetes cluster and no git change detected ( false by default )
  selfHeal: Boolean?

  /// Allows deleting all application resources during automatic syncing ( false by default )
  allowEmpty: Boolean?
}

class SyncOptions {
  /// If set to false, disables resource validation (equivalent to 'kubectl apply --validate=false') ( true by default )
  Validate: Boolean?

  /// Namespace Auto-Creation ensures that namespace specified as the application destination exists in the destination cluster
  CreateNamespace: Boolean?

  /// Supported policies are background, foreground and orphan.
  PrunePropagationPolicy: ("background" | "foreground" | "orphan")?

  /// Allow the ability for resource pruning to happen as a final, implicit wave of a sync operation
  PruneLast: Boolean?

  /// When syncing changes, respect fields ignored by the ignoreDifferences configuration
  RespectIgnoreDifferences: Boolean?

  /// Only sync out-of-sync resources, rather than applying every object in the application
  ApplyOutOfSyncOnly: Boolean?
}

class IgnoreDifferencesSpec {
  /// Group selector
  group: String?

  /// Kind selector
  kind: String?

  /// Ignore the specified json pointers
  jsonPointers: Listing<String>?

  /// Ignore the specified jq path expressions
  jqPathExpressions: Listing<String>?

  /// Ignore the specified managedFields managers
  managedFieldsManagers: Listing<String>?

  /// Optional name selector
  name: String?

  /// Optional namespace selector
  namespace: String?
}

output {
  local convertDcfgKeys = Set("exclude", "include")
  renderer {
    converters {
      [DirectoryConfig] = (dcfg: DirectoryConfig) -> dcfg.toMap().mapValues((key: String, value: Any) ->
        if (convertDcfgKeys.contains(key))
          let (list = value as Listing<String>)
          if (list.length == 1)
            list[0]
          else
            "{\(list.join(","))}"
        else value
      )
      [SyncOptions] = (so: SyncOptions) -> so.toMap()
        .filter((_, value: Any) -> value != null)
        .entries
        .map((pair: Pair) -> "\(pair.first)=\(pair.second.toString())")
      [Duration] = (dur: Duration) ->
          if (dur.unit == "s") dur.toUnit("s").value.toString() + "s"
          else if (dur.unit == "min") dur.toUnit("min").value.toString() + "m"
          else dur.toUnit("h").value.toString() + "h"
    }
  }
}
